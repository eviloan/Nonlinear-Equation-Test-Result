\documentclass{jssms}
%建议使用此模版前登陆www.ctex.org/CTeXDownload下载Latex软件.
%此模板需调用宏包jssms.cls, 请确保此宏包与tex文件在同一文件夹下.
%请使用CCT&LaTex编译.


\numberwithin{equation}{section}
% 公式编号会随着Section而变动,如(1.1),(1.2),(2.1)...,如果不便使用,您可以将这个命令删去
%--------------文内自定义命令----------------


\def\RM{\rm}
\def\It{\it}
\def\hat{\widehat}
\def\tilde{\widetilde}
\def\bar{\overline}
\def\epsilon{\varepsilon}
\def\dd{{\rm d}}
\def\ii{{\rm i}}
\def\ee{{\rm e}}
\def\q{\quad}
\def\dint{\displaystyle\int}
\def\vsp{\vspace{1mm}}
\def\no{\nonumber}
\def\q{\quad} \def\qq{\qquad}
\def\ay{\arraycolsep=1.5pt}
\def\d{\displaystyle}
\def\dfrac{\displaystyle\frac}
\def\la {\langle}              \def\ra {\rangle}
\def\n{\noindent}
\def\*{$\!\!^{^{^{\displaystyle *}}}$}
%**************************************************
\def\jssmszi{\zihao{10}\ziju{0.135}}
\parindent=2\ccwd
\def\rmn#1{\romannumeral #1}
\def\Rmn#1{\expandafter\uppercase\expandafter{\romannumeral #1}}
\def\cases#1{\left\{\,\vcenter{\normalbaselines \openup\jot
    \ialign{$\displaystyle{##}$\hfil&\quad{##}\hfil\crcr#1\crcr}}
    \right.}
%---------------------------------------
%--------------文内自定义命令结束------------

%--------------作者自定义命令----------------
\usepackage{algorithm,algorithmicx,supertabular,array}


%--------------作者自定义命令结束------------

%*************************************************
%***************************************

%-------------正文开始------------------
\begin{document}

\thispagestyle{empty}


\Volume{20xx}{x}{x}{x}               % 年,月,卷,期
\PageNum{1}                                  % 起始页码
\PaperID{0583-1431(20xx)0x-0xxx-0x}   % 文章编号
\DocumentCode{A}                              % 文献标识码
\EditorNote{*国家自然科学基金(11471209);中央高校基本科研业务费专项资金(78210152).}%如 *国家自然科学基金(10171074)资助课题.  如没有基金项目请删去此行


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%  作者从下面开始填写各项内容,本刊的标点符号均使用英文标点,您可以在编译前设置标点形式

\EditorNote{收稿日期: 200x-xx-xx, 收到修改稿日期: 200x-xx-xx.}  % 脚注
\EditorNote{编委:  }% 脚注,作者不必填写.

\TitleMark{作者姓名: 论文标题缩写}
% 页眉, 如有多位作者,请写为: 第一作者姓名等: 论文标题缩写

\BeginTitle

\Title{一种非线性方程组全局区间解的高性能算法\*}

\Author{林当$^{1}$\q\q 陈良育$^{2}$\q\q}%例如: 张\ 小\ 乙
 {(1. 华东师范大学,\, 上海\ 200062; 2. 华东师范大学,\, 上海\ 200062)} % 例如 (中国科学院数学与系统科学研究院,\ 北京 100190)



\Abstract{非线性代数方程组求解是一个经典的数学问题, 在科学研究和工程实践中的应用十分广泛. 当前, 有多种符号和数值的求解算法.这些算法受复杂度高、单机计算慢、中间表达式膨胀等因素制约, 在面对多变元(如6个以上)等复杂情况, 其计算效率差强人意.根据现实物理世界注重变量实解的特点, 针对一类变元带约束范围的非线性多项式方程组, 本文提出了基于GPGPU 的全局区间搜索算法, 解决了串行计算速度慢的问题. 该方法利用GPGPU 并行计算的特点,加速了计算过程,并实现了基于GPGPU 的Hansen-Sengupta 算法,进一步加快了区间削减的速度,隔离实根的数量. 实验表明, 本文的算法可以高效解决一些非线性多元多项式问题, 计算结果准确, 计算速度与串行方法相比有了大幅度提升.}

\Keywords{非线性方程组, 区间计算, GPGPU,并行计算.}%甲, 乙, 丙, 丁.

\MRClass{MR分类号1, MR分类号2}%需作者自己提供

\ETitle{A HIGH PERFORMANCE ALGORITHM FOR GLOBAL INTERVAL SOLUTION OF NONLINEAR ALGEBRA SYSTEM} %英文标题名称全大写

\EAuthor{\uppercase{LIN} Dang$^{1}$\q\q \uppercase{CHEN} Liangyu$^{2}$\q \q} % 作者姓名的拼音,姓在前,名在后,
{\small(1. {\it East China Normal University,\, Shanghai} 200062; 2. {\it East China Normal University,\, Shanghai} 200062)}
% 如 \small({\it Academy of Mathematics and Systems Science, Chinese Academy of Sciences, Beijing} 100190) \\


%\EAuthor{\uppercase{XING} Ming\q \q \uppercase{XING} Ming}
%{\small(Author's Address)}

%顺序相邻的几个作者若单位相同,合并在一起排版.

\EAbstract{In this paper, We concerned with nonlinear algebra system,nonlinear algebra system is a  classic mathematical problem,widely applied in scientific research and engineering practice,there are many symbolic and numeric methods of solving solutions, these methods constrain by high complexity,slow stand-alone calculation,expands of the intermediate expression,the efficiency is low when we dealing with multivariate problem,especially the variate are more than six.According to the physical world,we pay attention to characteristic of real solutions,variate with constraint nonlinear system,we present a global interval algorithm based on GPGPU,solving the nonlinear system with interval Arithmetic,and combined with parallelism of GPGPU,accelerate the calculation process.Furthermore,we realize the Hansen-Sengupta method in GPGPU,to cutting the number of boxes of isolation root. Experiments shows that our method can solve many nonlinear algebra system,the result are accurate and more efficiency compared to traditional serial methods.}

\EKeywords{nonlinear system, interval, GPGPU,parallel computing}%Jia, yi, bing, ding.


\EndTitle



\Section{概\ \ 述}

代数方程组的准确求解的构造性理论和算法研究是一个非常经典且十分重要的问题.很多科学研究和工程实际问题, 最终都转化成方程组进行求解.对于线性方程组, 已经进行了非常深入的研究.在目前的单机上, 已经可以准确求解上万维或者更高的线性代数方程组, 对于非线性代数方程组, 也有多种符号和数值方法.对于非线性代数方程组准确求解方法可以分成符号算法和符号-数值算法.符号计算方法研究有吴方法\supercite{ref24}、Groebner基\supercite{ref14}、结式消元法\supercite{ref25}以及其他的一些算法.近年来也逐步发展起来一些符号-数值方法, 既保留了符号计算的准确性, 又在保证准确性的基础上, 将一些运算复杂的符号计算步骤替换为纯数值操作, 减少内存消耗, 加快计算进度.以上很多非线性方程组求解方法也都实现为具体的软件包, 如Maple中的Groebner包、WSolve\supercite{ref21}、Discoverer \supercite{ref20,ref26}、GAS\supercite{ref25}、Epsilon\supercite{ref23} 等.目前国内外在非线性代数方程组的求解研究方面已经开展了多层次的研究, 并取得了诸多的研究成果, 但随着在航天控制、智能交通、程序验证及物联网等领域广泛应用及其相关领域的迅猛发展, 为非线性代数方程组求解研究又带来了诸多的问题与挑战.当前, 各种方法和工具主要存在以下的局限：
1)计算速度不足.上文所述的各种具体的软件包, 目前大都只能运行在单台计算机上, 由单个CPU核运行, 不容易扩展到多个计算机或集群计算机上使用, 且都是只能依赖于CPU指令运行, 不能充分发挥其他计算部件的能力.
2)中间表达式膨胀导致内存不足.符号计算由于其计算的准确性, 且处理的对象以符号表达式为主, 而且计算过程中表达式不能省略, 浮点数字完全保留没有舍入误差, 所以极其容易发生中间表达式膨胀问题, 同样不仅导致计算速度较慢, 而且甚至造成无法顺利完成计算.

\par
当前计算机已跨过多核时代(multi-core age), 迈向众核时代(many-core age), 很多计算机已经配置多个CPU计算核, 目前一般是4或8核,而Intel的MIC架构的CPU, 一个CPU 内具有32 个计算核.此外, 现代计算机部件中不仅只有CPU可以计算, GPU(Graphic Processing Unit)计算也已经得到了很大的推广和普及.经过调优的GPU程序可以起到非常快的计算效果.在计算设备性能飞速提升的同时, 却是传统的符号计算程序仍遵循旧有串行程序CPU执行的特点, 只依靠一个CPU计算核的计算能力和本机所配置的物理内存, 计算受到极大的限制, 速度缓慢, 内存膨胀导致不足, 无法顺利完成计算任务.
将并行计算和符号计算相结合, 利用并行计算加速符号计算过程, 已经成为当前和将来的一段时间的研究的主流.例如Paul S. Wang关于多项式因式分解在分布式和并行计算环境下的实现方法\supercite{ref19}, 林东岱对多项式最大公因子(GCD)和吴方法的并行实现\supercite{ref22,ref17}, Y.Sato等关于Groebner基的并行计算研究\supercite{ref16}, Marc等关于多项式组三角化的并行计算研究\supercite{ref17}, 李廉、李斌、王建林, Hidetsune Kobayashi和Ono Yoko等人关于形式化验证语言Isabelle的并行实现等.采用GPU技术将复杂符号计算问题(例如复杂的符号行列式展开和结式计算)归结为模运算下的大规模数字行列式计算及结果符号表达式恢复, 最近有一些学者开始理论分析及实例计算方面的工作, 如\cite{ref15,ref18}.

%例如,基于符号算法的求解方法主要有Groebner基,结式方法,吴方法以及其他算法,符号算法的优势在于能够准确地求得多项式方程组的全部解.基于数值算法的求解方法主要有区间算法,迭代算法,同伦算法特征值与特征向量法等,传统的数值算法里,求解多项式方程组的算法都是由一个近似解作为初始点开始,通过一系列的迭代提高近似解与准确解的近似度直至收敛性或者终止性条件得以满足.这些非区间数值算法的困难在于不能够求得给定问题的全部解.数值算法的优势在于能够快速求解方程组,但是往往不能用于求在给定区域内多项式方程组的全部解符号一数值混合算法结合符号计算的精确性和数值计算的高效性的优势,能够快速准确地求解方程组,但是如何才有但是 如何才有有效地将符号和数值算法的优点相结合,仍旧是目前研究的一个热点问题.
\par
%区间计算是符号计算中一项基本的运算,它最初是从计算数学的误差理论研究发展起来的.1966年R.E.Moore在《Interval Analysis》一书中第一次系统提出区间运算理论.在20世纪60年代,E.R.Hansen提出了关于线性方程的区间计算的扩展方法,对全局优化方法做出了很大的贡献,其中包括的在区间计算领域应用广泛的Hansen算法. 1988年, Rudolf Lohner 发明了基于Fortran语言的针对常微分方程的可信区间计算.近年来,区间计算的工作主要集中在对参数化函数的预图像的估计,以及法国COPRIN小组的健壮控制理论.
%\par
%区间计算与传统的以数为对象的运算(即点计算)不同,它的运算对象是区间.区间计算最早应用于计算误差控制领域.由于数字计算机只能使用有限位数表示实数,不能精确表达数学意义上的数值,所以数值的每一步计算都会产生误差.亿万次计算之后,计算机的"舍入规则	效应可能累积相当大的计算误差,导致数值计算结果精度严重损失.而区间计算的整个过程以"区间"为运算对象,提供区间形式的计算结果.这些运算区间在构造上保证包含数据的真实值,使得结果区间也能够保证包含数据运算的真实结果.
%\par
%分枝定界法(Branch and Bound Method)是一种搜索与迭代的方法, 第一次由A.H.Land and A.G.Doig在20世纪60年代提出,分枝定界法的名称是由Richard M.Karp在20世纪60 年代成功求解含有65个城市的旅行商问题时提出.分枝定界法是解决NP-Hard问题最广泛的算法之一.分枝定界法把问题的可行解展开如树的分枝,再经由各个分枝中寻找最佳解,是一种在问题的解空间树上搜索问题的解的方法.分枝定界法的基本思想是对有约束条件的最优化问题的所有可行解(数目有限)空间进行搜索.该算法在具体执行时,把全部可行的解空间不断分割为越来越小的子集(称为分枝),并为每个子集内的解的值计算一个下界或上界(称为定界).在每次分枝后,对凡是界限超出已知可行解值那些子集不再做进一步分枝.这样,解的许多子集(即搜索树上的许多结点)就可以不予考虑了,从而缩小了搜索范围.这一过程一直进行到找出可行解为止,该可行解的值不大于任何子集的界限.因此这种算法一般可以求得最优解.将问题分枝为子问题并对这些子问题定界的步骤称为分枝定界法.
%\par
本文根据传统基于分枝定界法\supercite{ref2}的区间计算\supercite{ref1,ref10,ref28}实现了基于GPGPU的非线性方程组实解并行求解算法.我们观察到,很多具有实际物理意义的问题最后都转化成非线性多项式方程组,并且都具有两个特征,1)取值范围受限,2)求实解.我们利用分枝定界法的朴素思想,将全局解空间迭代剖分,借助Hansen-Sengputa算法\supercite{ref4,ref5,ref7,ref13}对各待定区间进行实解判定,最后筛选出包含真正实解的区间. 我们的算法有以下几个特点：1)是全局的, 不会丢失或者遗漏系统的实根. 2)采用可靠的区间计算方法, 对于整系数或者浮点数的多项式方程组都适用. 3)采用GPGPU来加速全局解空间的迭代剖分, 计算效率得到大幅提升, 而且不会出现中间表达式膨胀等问题.

%从传统的角度来看,常用的软件通常按照串行计算的思维进行编写,也就是说,一个问题被解决的关键在于实现一连串按顺序执行的指令集组成的算法.这些指令通常在一台电脑的一个CPU 核上串行执行,即在某一时刻有且仅有一条指令在运行,下一条指令必须等待上一条指令执行完成后才能被执行.而与此相反,并行计算则依赖于多个计算处理单元同时运行来解决一个问题.并行计算的顺利执行得益于将一个问题分割成几个独立的部分,而每个处理器因此能够同时处理各自的子问题,并进行相互间的协作通信来完成整个待解决的问题.

\par
文章的组织结构如下:第1节中叙述了本文所涉及相关技术的问题描述,第2节给出了文章算法所需的基础知识,第3节提出并详述了本文实现的算法,包括并行环境下算法的整体流程,区间计算,分枝定界算法,Hansen-Sengupta算法在GPGPU上的实现,实验结果将在第4节中展示,最后是结束语.

\Section{基础知识}
\Subsection{2.1\ \ 多项式方程组}
多项式(Polynomial)是代数学中的基础概念,是由称为不定元的变量和称为系数的常数通过有限次加减法,乘法以及自然数幂次的乘方运算得到的代数表达式.例如
$x^{2}-3x+4$就是一个多项式.
多项式在数学的很多分枝中乃至许多自然科学以及工程学中都有重要作用.
\par
多项式方程是指多项式函数构成的方程.给定多项式
\begin{eqnarray}\label{eq:1}
P=a_{0}+a_{1}X+\cdots +a_{n}X^{n}.
\end{eqnarray}
\par 则对应的多项式函数可以构造方程:
\begin{eqnarray}\label{eq:2}
f_{P}(x)=a_{0}+a_{1}x+\cdots +a_{n}x^{n}=0.
\end{eqnarray}
\par 如果某个 $r\in \mathbb {A}$使得多项式方程$f_{P}(r)=0$,那么就称$r$为多项式方程的解,或多项式函数的一个根或零点.多项式函数的根与多项式有如下关系:如果某个 $r\in R$ 是多项式函数$ f_{P}$的一个根,那么一次多项式$X-r$整除多项式 $P$,也就是说存在多项式$Q$,使得:$P=(X-r)Q$;反之亦然.如果存在(一般来说大于$1$的)正整数$k$,使得 $P=(X-r)^{k}Q$,那么称 $r$ 是多项式函数的一个$k$重根.
\par 实数根就是指方程式的解为实数,代数基本定理说明,复系数多项式在复数域内必然有至少一个根.这可以推出,  $n$ 次多项式函数必定有$n$个根.这里说的$n$个根指包括了重根的情况.另外可以证明,奇数次实系数多项式在实数域内至少有一个根.
多项式的根是否存在以及根的数目取决于多项式的系数域以及指定的根所在的域.
多项式方程组的实根隔离就是求实数轴上一列互不相交的区间,使其包含该多项式的所有实根,而且其中的每个区间有且仅有一个实根.
\Subsection{2.2\ \ 区间计算}

%区间计算的概念是利用实数的区间来代替实数进行计算,传统的浮点数运算由于舍入误差会产生不准确的结果,而区间计算更够产生严格的上下界,区间计算的一种应用是在某些参数未知而另一些参数已知在某些区间中,算法就可以通过将无法确定的参数转换成区间从而产生所有可能的结果.

%在本节中我们将介绍一些区间运算的基本知识.
区间数是一个非空的实数集合:
\begin{eqnarray}\label{E:2.3}
I=[\underline{x},\overline{x}]=\{x \in \mathbb{R}:\underline{x}\leq x\leq \overline{x} \},
\end{eqnarray}
\par 其中$\underline{x}$称为下界,$\overline{x}$称为上界,所有区间数的集合可以表示成:
\begin{eqnarray}\label{E:2.4}
\mathbb{IR}=\{[\underline{x},\overline{x}]:\underline{x},\overline{x}\in \mathbb{R},\underline{x}\leq \overline{x} \}.
\end{eqnarray}
\par 区间中点:\begin{eqnarray}\label{E:2.5}
c=mid(x)=(\underline{x}+\overline{x})/2.
\end{eqnarray}
\par 区间半径:\begin{eqnarray}\label{E:2.6}
rad(x)=(\underline{x}+\overline{x})/2.
\end{eqnarray}

\par 区间计算的基本运算是定义在$\mathbb{IR}$上的,所以区间计算的结果包含了所有可能的实数解,有$x=[\underline{x},\overline{x}],y=[\underline{y},\overline{y}]$, 则区间的四则运算的表示如下:
\begin{eqnarray}\label{E:2.7}
x+y=[\underline{x}+\underline{y},\overline{x}+\overline{y}].
\end{eqnarray}
\begin{eqnarray}\label{E:2.8}
x-y=[\underline{x}-\overline{y},\overline{x}-\underline{y}].
\end{eqnarray}
\begin{eqnarray}\label{E:2.9}
x\times y=[min\{\underline{x}\underline{y}, \overline{x}\underline{y},\underline{x}\overline{y},\overline{x}\overline{y}\},max\{\underline{x}\underline{y}, \overline{x}\underline{y},\underline{x}\overline{y},\overline{x}\overline{y}\}].
\end{eqnarray}
\begin{eqnarray}\label{E:2.10}
1/x=[1/ \overline{x},1/ \underline{x}] \quad if \ \underline{x} > 0 \ or \ \overline{x}<0.
\end{eqnarray}
\begin{eqnarray}\label{E:2.11}
x \div y = x \times 1/y.
\end{eqnarray}
\par 在这些基础运算中,包含零点的区间是没有定义的,我们给包含零点的区间除法定义为"扩展的区间计算法则",法则如下:
\begin{displaymath}
x/y = \left\{ \begin{array}{ll}
 [\overline{x}/\underline{y},+\infty] \ & \textrm{:$ \ if \ \overline{x}  \leq 0 \ and \ \overline{y}=0 $},\\

[-\infty,\overline{x}/\overline{y}] \bigcup [\overline{x}/\underline{y},+\infty]  & \textrm{:$ \ if \ \overline{x}  \leq 0 \ and \ \underline{y} < 0 < \overline{y}$},\\

 [-\infty,\overline{x}/\overline{y}] \ & \textrm{:$ \ if \ \overline{x}  \leq 0 \ and \ \underline{y}=0 $},\\

  [-\infty,+\infty] \ & \textrm{:$ \ if \ \underline{x}  < 0  < \overline{x}$},\\

 [-\infty,\underline{x}/\underline{y}] \ & \textrm{:$ \ if \ \underline{x}  \geq 0 \ and \ \overline{y}=0 $},\\

 [-\infty,\underline{x}/\underline{y}] \bigcup [\underline{x}/\overline{y},+\infty]  & \textrm{:$ \ if \ \underline{x}  \geq 0 \ and \ \underline{y} < 0 < \overline{y}$},\\

  [\underline{x}/\overline{y},+\infty] \ & \textrm{:$ \ if \ \underline{x}  \leq 0 \ and \ \underline{y}=0 $}.\\

\end{array} \right.
\end{displaymath}
\par 区间估值是估值多项式函数$f$在区域$X$上的界,具体的
\par
{\HT 定义 1}\ \ 设$f$是$\mathbb{R}[x_1,x_2,\ldots,x_n]$中某个多项式的算术表示,将所有操作数转成区间,所有的运算可以看做对应的区间运算,结果记作$F$,那么$F:I(\mathbb{R})^n \rightarrow I(\mathbb{R})$称作一个区间估值,简单地,$Y \supseteq {f(x):x \in X}$表示$f(x)$在区间$X$上的估值.
\par
大体上,函数在给定区间上的区间估值有以下三种方法:
\par 1)利用代数或者分析的方法,给出函数在给定区间上的区间估值.
\par 2)将给定区间划分成若干子区间,计算给定函数在子区间上的区间函数值,求其并集的边界作为该函数在给定区间的区间估值.
\par 3)利用优化方法求函数在给定区间的最大最小值作为区间估值.
\par 我们本文主要使用给定区间直接计算函数在该区间的区间函数值,原因在于GPGPU 上计算浮点数的运算速度快,通过直接估值可以大大减少估值的时间,第二在区间估值优化的方法不具有普适性,在本文中讨论的多元多项式中的优化效率不明显.本文通过利用结合基于分枝定界算法的区间算法来计算非线性多项式的解,结合符号计算的精确性和数值计算的高效性能够快速的求解方程组的全部解.
\par {\HT 定义 2}\ \ 我们称各元素是区间的矩阵为区间矩阵.所有$n$阶实区间矩阵组成的集合成为$I(R^{n \times n})$.实区间矩阵$[X] \in I(R^{n \times n})$,其中$[X]_{ij} \in I(R)(i,j=1,2,\ldots,n).$
\begin{eqnarray}\label{E:3.1}
[X]=\begin{bmatrix}
[\underline{x_{11}},\overline{x_{11}}] &[\underline{x_{12}},\overline{x_{12}}]&\cdots & [\underline{x_{1n}},\overline{x_{1n}}]\\
[\underline{x_{21}},\overline{x_{21}}] &[\underline{x_{22}},\overline{x_{22}}] &\cdots & [\underline{x_{2n}},\overline{x_{2n}}]\\
 \vdots   & \vdots & \ddots  & \vdots  \\
[\underline{x_{n1}},\overline{x_{n1}}] &[\underline{x_{n2}},\overline{x_{n2}}] &\cdots & [\underline{x_{nn}},\overline{x_{nn}}]
\end{bmatrix}
\end{eqnarray}
\Subsection{2.3\ \ Hansen-Sengupta算法}
Hansen-Sengupta算法是一种基于区间计算求解非线性方程根的算法,也可以利用该算法测试给定区域内解的存在性,Hansen-Sengupta算法是可以看成基于区间牛顿算子\supercite{ref5,ref8,ref9}的算法的改进.
\par
{\HT 定义 3}\ \ 设$f(x) \in \mathbb{R}[x],X$是一个区间,$c$是区间$X$的中点,区间牛顿算子的定义为
\begin{eqnarray}\label{E:3.1}
N(x)=c-F'^{-1}(X)f(c).
\end{eqnarray}
\par 其中,$F'$是$f$的导数$f'$在区间$X$上的区间估值,一般可以写作,
\begin{eqnarray}\label{E:3.1}
f(x)+J(\xi)(z-x)=f(y)=0.
\end{eqnarray}
\par 其中,$\xi \in X$,$J(\xi)$是$f(x)$在点$\xi$的Jacobian矩阵,点$z$所属的集合$Z$ 包含了多项式方程组的解$y$.
尽管这个区间牛顿算法能够简单地隔离多项式的实根,但是效率很低.主要原因在于$f(x)$在区间$X$上的估值比实际的$f(X)$要相差很多,这导致我们不能很快地排除那些不含根的区间,因而产生了大量的冗余计算.在Moore提出的区间牛顿算法中, 需要计算区间矩阵的逆, 那么就要求$F(X)$是非退化的.Hansen在\cite{ref14}中指出:区间牛顿算子中并不必求区间矩阵的逆, 取而代之地,可以用Guass-Seidel迭代法来求解.他提出使用预处理方法能够有助于计算,引入数值矩阵$F'(c)$,其中每个元素都是$F(X)$每个对应元素的中点,即,建立一个预处理矩阵$m=(F'_c)^{-1}$,则上式可以改写为
\begin{eqnarray}\label{E:3.1}
mf(x)+mJ(X)(z-x)=0.
\end{eqnarray}
\par Krawczyk提出了一种改进区间牛顿算法,无需获取(2)式的精确值,从而避免了Guassian 消除区间矩阵,即
\begin{eqnarray}\label{E:3.1}
K(X)=x-mf(x)+[I-BJ(X)](X-x).
\end{eqnarray}
\par 如果计算的结果$y$包含在我们的区间X中,那么$y$也包含在Krawczyk方法计算的结果集$K(X)$,然而$K(X)$并不一定包含在$X$ 中,所以我们需要利用迭代
\begin{eqnarray}\label{E:3.1}
X^{(i+1)}=X^{i} \cap K(X^{i})  \ (i=0,1,\ldots,n).
\end{eqnarray}
\par 可以看出来,这是一个持续性迭代的算法,然而我们可以通过持续性的迭代获得极大的收敛性.然而Krawczyk算法并不能获得最小的结果集,Hansen-Sengupta算法可以获得通常更小的结果集,即每次迭代都能对区间进行更大的削减,这样我们需要的迭代次数也会大大减少.
\\
\par 我们把上面的式表示成$g=mf(x),P=mJ(X)$,则上式则变成
\begin{eqnarray}\label{E:3.1}
g+P(z-x)=0.\end{eqnarray}
\par 我们把区间$P$写成
\begin{eqnarray}\label{E:3.1}
P=L+D+U.
\end{eqnarray}

\par 矩阵$L,D,U$分别为下三角矩阵,对角矩阵和上三角矩阵.相应的,我们的结果$X'$可以写成
\begin{eqnarray}\label{E:3.1}
Y=x-D^{-1}[g+L(X'-x)+U(X-x)], \ X'=Y\cap X.
\end{eqnarray}
\par 每当我们计算出新的$Y_i(i=1,2,\ldots,n,)$,就可以通过和$X_i$产生交集$X'_i=Y_i \cap X_i$,而接下来我们可以通过$X_i$ 来计算$Y_{i+1},Y_{i+2},\ldots,Y_n$,这样我们也可以得到
\begin{eqnarray}\label{E:3.1}
Y_i=x_i-(D_{ii})^{-1}[g_i+ \sum_{j=1}^{i-1}P_{ij}(X'_j-x_j)+ \sum_{j=i+1}^nP_{ij}(X_j-x_j)].
\end{eqnarray}
\begin{eqnarray}\label{E:3.1}
X'_i=Y_i \cap X_i.
\end{eqnarray}
\par 通过公式我们还可以注意到一个问题,即使$P$是一个近似的单位矩阵,但是对$D_{ii}$ 来说,可能会存在一个或者多个包含零点的区间,这时候我们就要使用到我们前面提到的"拓展的区间计算法则"来计算区间除法.
\Subsection{2.4 \ \ Guass-Jordan法求逆矩阵}
Guass-Jordan法\supercite{ref6}是计算逆矩阵的经典算法,特点是计算稳定,而且不需要考虑矩阵的类型.
考虑一个$n$阶矩阵$A$,Guass-Jordan法的求解步骤如下,首先,我们在$A$矩阵右边增加一个单位矩阵,得到矩阵$C$
\begin{eqnarray}\label{E:3.1}
[C]=[A|I].
\end{eqnarray}
\par 第二步我们对矩阵C做初等行变换,我们的目的是要将左边的矩阵转化成单位阵,则我们的这个步骤可以分成两个部分,首先我们将$a_{ii}$变换成1
\begin{eqnarray}\label{E:3.1}
R_{ii} \leftarrow R_{i}/a_{ii}.
\end{eqnarray}
\par 如果$a_{ii}$为0,则任何非零行都会在上一步之前加到第i行上,第二部分我们要做的是将除了第j行的第j列的元素变换为0
\begin{eqnarray}\label{E:3.1}
R_i \leftarrow R{i}-R_j \times a_{ij}.
\end{eqnarray}
对矩阵每一列都做以上两部处理,左边一半的$C'$变为单位阵,而右边的一半即是我们需要的逆矩阵$A^{-1}$
\begin{eqnarray}\label{E:3.1}
[C']=[I|A^{-1}].
\end{eqnarray}

\Section{基于分枝定界的非线性方程组区间算法}
\Subsection{3.1\ \ 算法整体框架}
本文算法的研究对象是有变元带有取值范围的非线性多项式方程组的实根求解问题.由于所有的变元都受限于一个区间中,这些变元初始取值区间组合起来,就形成了全局解空间.利用分枝定界法的基本思想进行区间的剖分,区间的剖分可以看成$n$维矩形的剖分\supercite{ref27},把区间分割成多个小矩形,每个小矩形可以看成一个未知数的取值范围,$n$个小矩形可以看成一个区间组,我们利用多项式的区间估值对每一个区间组进行估值计算,进行判定,筛选出符合条件的区间组.
接下来我们再将获得的区间组作为下一轮剖分的输入,将算法进行迭代,以获得宽度足够小的区间. 如此进行多次重复迭代,直至区间精度满足预定的求解要求.
因此,我们提出如下的算法1,算法流程图如图1所示.
\begin{algorithm}[H]
\caption{基于分枝定界的非线性方程组区间算法} %算法的名字
\hspace*{0.02in} {\bf 输入:} %算法的输入, \hspace*{0.02in}用来控制位置,同时利用 \\ 进行换行
非线性多项式方程组及未知数受限范围\\
\hspace*{0.02in} {\bf 输出:} %算法的结果输出
符合条件的区间组
\begin{algorithmic}
\State 1 \ \ 将待求解的方程的未知数受限范围转换为区间,建立全局的解空间，利用分支定界法进行区间剖分.\\
2\ \ 对处理之后的区间方程组进行区间估值计算,判定出符合条件的区间组.\\
3\ \ 对符合条件的区间组使用Hansen-Sengupta算法,对区间组进行进一步判定,缩减区间组的数量.\\
4\ \ 判断区间组的数量是否稳定,如数量还在增长,返回第2步，执行将前一轮计算符合条件后输出的区间组做为,迭代计算.如果数量基本趋于稳定,执行区间回溯算法.\\
5 \ \ 输出符合条件的区间组.
\end{algorithmic}
\end{algorithm}


\ \ 在迭代计算的过程中,由于区间组的数量不断增加,仅通过区间估值我们可能无法所需要的结果,接一下我们需要利用基于GPGPU 的Hansen-Sengupta算法对方程的区间组作进一步判定,通过对区间解的存在性进行判定,排除不符合条件的区间组,Hansen-Sengupta 算法中还包括了区间矩阵乘法,Guass-Jordan法求逆矩阵算法等子算法,在计算预处理矩阵的时候需要使用区间矩阵乘法,获得方程Jacobian矩阵需要使用到矩阵求逆算法.
\ \ 经过不断迭代以上两个算法,我们能得到稳定数量个的宽度符合要求的区间组,此时我们需要对区间进行回溯计算,区间回溯算法的作用是将分枝定界法得到的区间组进行回溯合并,将计算出的子区间合并至上层,迭代进行之后隔离出实根.
\begin{center}
\centerline
  {\includegraphics[scale=0.35]{p1.pdf}}
\centering{\small 图1\ \ 算法整体流程图}\\
 \centerline{\small (Figure 1\ \ The overall flow chart of the algorithm)}%% 图中文标题下附英文标题翻译. }
\end{center}
\Subsection{3.2\ \ 基于GPGPU的多项式区间估值快速算法}
基于GPGPU支定界区间估值算法基本思想是将未知数的初始取值范围转化成区间,利用分枝定界法的基本思想进行区间的剖分,区间的剖分可以看成$n$维矩形的剖分,把区间分割成多个小矩形,每个小矩形可以看成一个未知数的取值范围,$n$ 个小矩形可以看成一个区间组,我们利用多项式的区间估值对每一个区间组进行估值计算,进行判定,筛选出符合条件的区间组.再将获得的区间组作为下一轮剖分的输入,将算法进行迭代,以获得宽度足够小的区间.
\par 在GPU在进行区间估值的过程中, 由于计算精度的误差问题, 我们需要对区间计算结果的上下界进行处理,在GPU的浮点数运算过程中,可以通过IEEE标准提供的模式对下界进行向下舍入(rd),对上界进行向上舍入(ru), 保证区间定界结果的正确性,加,减,乘法运算的法则为
\begin{eqnarray}\label{E:3.1}
x+y=[rd(\underline{x}+\underline{y}),ru(\overline{x}+\overline{y})].
\end{eqnarray}
\begin{eqnarray}\label{E:3.1}
x-y=[rd(\underline{x}-\overline{y}),ru(\overline{x}-\underline{y})].
\end{eqnarray}
\begin{eqnarray}\label{E:3.1}
x \times y=[rd(min\{\underline{x}\underline{y}, \overline{x}\underline{y},\underline{x}\overline{y},\overline{x}\overline{y}\}),ru(max\{\underline{x}\underline{y}, \overline{x}\underline{y},\underline{x}\overline{y},\overline{x}\overline{y}\})].
\end{eqnarray}
\begin{algorithm}[H]
\caption{基于GPGPU的多项式区间估值快速算法} %算法的名字
\hspace*{0.02in} {\bf 输入:} %算法的输入, \hspace*{0.02in}用来控制位置,同时利用 \\ 进行换行
初始区间$I_1=[\underline{a_1},\overline{a_1}],I_2=[\underline{a_2},\overline{a_2}],\cdots,I_n=[\underline{a_n},\overline{a_n}] $\\
\hspace*{0.02in} {\bf 输出:} %算法的结果输出
$2^N$个子区间组合
\begin{algorithmic}
\State 1\ \ 将N个区间进行等分分割成$2N$个区间,
$I_{11}=[\underline{a_1},mid(\underline{a_1}+\overline{a_1})],I_{12}=[mid(\underline{a_1}+\overline{a_1}),\overline{a_1},],\ldots,I_{n1}=[\underline{a_n},mid(\underline{a_n}+\overline{I_n})],I_{n2}=[mid(\underline{a_n}+\overline{a_n}),\overline{a_n},]]$. \\
2\ \ 从$2N$个子区间的每个原始区间中选择1个子区间,形成一个区间组,排列组合之后共有$2^N$个区间组合.\\
3\ \ 将$2^N$个区间放入$2^N$个GPU线程,每个线程计算一条区间组的函数估值.\\
4\ \ 将前一轮计算符合条件后输出的区间组做为下一轮分枝组合的的输入,迭代计算.\\
5\ \ 输出子区间组合.
\end{algorithmic}
\end{algorithm}
\Subsection{3.3\ \ 基于GPGPU的Hansen-Sengupta算法}
在全局搜索的过程中区间组的个数可能会快速增长,这样我们就很难得到我们需要的结果,我们需要利用Hansen-Sengupta算法对全局搜索出的区间组进行判定,将不符合要求的区间组进行排除,提高搜索的速度.
根据之前的介绍我们可以写出在GPGPU中Hansen-Sengupta算法的流程
\begin{algorithm}[H]
\caption{Hansen-Sengupta算法} %算法的名字
\hspace*{0.02in} {\bf 输入:} %算法的输入, \hspace*{0.02in}用来控制位置,同时利用 \\ 进行换行
$f={f_1,f2,\ldots,f_n} \in \mathbb{Q}[x_1,x_2,\ldots,x_n],box \ B=X_1 \times X_2 \times \cdots \times X_n$\\
\hspace*{0.02in} {\bf 输出:} %算法的结果输出
$box \ B^*$使得\\
(a) $\forall (x_1,x_2,\ldots,x_n) \in B,$ 如果 $f(x_1,x_2,\ldots,x_n)=0$ 则 $x_1,x_2,\ldots,x_n \in B^*$\\
(b)如果$B^* \in B$ 则 $\exists(x_1,x_2,\ldots,x_n) \in B^*,f(x_1,x_2,\ldots,x_n)=0$
\begin{algorithmic}
\State 1\ \ 计算$f$的Jacobian矩阵,选取$X_1,X_2,\ldots,X_n$的区间,将Jacobian矩阵转化成区间形式的Jacobian矩阵$J(X).$
\State 2\ \ 取$J(X)$的中点,利用Guass-Jordans算法计算其近似的逆矩阵A=Inv(mid(J(X))).
\State 3\ \ 利用区间矩阵乘法计算矩阵$M=A*J(X),R(x)=A*f(x)$.
\State 4\ \ {\HT For}\ \ {$i=1,2,\ldots,n$} ,计算$P_i,N_i$,计算公式为:
$$P_i=R(x)-\sum_{j=1}^{i-1}M_{ij}(X'_j-x_j)-\sum_{j=i+1}^{n}M_{ij}(X_j-x_j).$$
$$N_i(x,X)=x_i+P_i/M_{ii}.$$

\State 5\ \ {\HT For}\ \ {$i=1,2,\ldots,n$}, 计算$X_i$,计算公式为:
$$X'_i=X_i \cap N_i(X).$$
\State 6\ \ 得到区间组$B^*=X'_1 \times X'_2 \times \cdots \times X'_n$
\end{algorithmic}
\end{algorithm}

\Subsubsection{3.3.1\ \ 区间矩阵乘法}
在GPU中实现Hansen-Sengputa算法的过程中我们需要使用区间矩阵乘法，区间矩阵乘法的基本算法和普通矩阵的乘法的不同之处在于由于区间矩阵的每一个元素都是区间，所以我们需要将矩阵的每一个元素利用区间乘法进行计算.
\begin{algorithm}[H]
\caption{区间矩阵乘法} %算法的名字
\hspace*{0.02in} {\bf 输入:} %算法的输入, \hspace*{0.02in}用来控制位置,同时利用 \\ 进行换行
区间矩阵$A\in \mathbb{R}^{m \times k},B \in \mathbb{R}^{k \times n},$其中每个元素均为一个区间$[\underline{d},\overline{d}]$.\\
\hspace*{0.02in} {\bf 输出:} %算法的结果输出
$C$
\begin{algorithmic}
\State 1\ \ 初始化区间矩阵$C$.\\
2 \ \ {\HT For} \ \ {$l=1,2,\ldots,k$}
$$\underline{C}_{ij} = \underline{C}_{ij}+min\{A_{ij}\times B_{ji}\}.$$
$$\overline{C}_{ij} = \overline{C}_{ij}+max\{A_{ij}\times B_{ji}\}.$$
3 \ \ 输出区间矩阵$C$.
\end{algorithmic}
\end{algorithm}
\Subsection{3.4\ \ 基于GPGPU的分枝定界回溯算法}
在全局搜索算法迭代到区间宽度较小且区间组个数趋于稳定时我们需要利用回溯算法将算法过滤出的实根进行隔离,隔离的方法即将第N轮的区间回溯到第N-1的区间,因为每轮区间是二分法等分分割的,通过判断左右区间边界是否被上层区间宽度整除则可以判断第N层区间的N-1层的回溯区间,然后将同属于一个区间组的结果进行合并,依次迭代,得到最后的隔离实根的个数.
\begin{algorithm}[H]
\caption{基于GPGPU的分枝定界回溯算法} %算法的名字
\hspace*{0.02in} {\bf 输入:} %算法的输入, \hspace*{0.02in}用来控制位置,同时利用 \\ 进行换行
K个区间$[\underline{a_1},\overline{a_1}]\times[\underline{a_2},\overline{a_2}]\times\cdots\times[\underline{a_n},\overline{a_n}] $\\
\hspace*{0.02in} {\bf 输出:} %算法的结果输出
J个回溯区间$[\underline{b_1},\overline{b_1}]\times[\underline{b_2},\overline{b_2}]\times\cdots\times[\underline{b_n},\overline{b_n}] $
\begin{algorithmic}
\State 1 \ \ 设a=(区间左边界/第N-1层区间宽度), b=(区间右边界/第N-1层区间宽度);\\
\ \quad $ \mbox{左边界}=\left\{
\begin{array}{ll}
\mbox{左边界+右边界/2}  & \mbox{a为整数} \\
\mbox{不变} & \mbox{a不为整数} \\
\end{array}
\right.
$ \\

\ \quad $ \mbox{右边界}=\left\{
\begin{array}{ll}
\mbox{不变} & \mbox{b为整数} \\
\mbox{左边界+右边界/2}  & \mbox{b不为整数} \\
\end{array}
\right.
$ \\
2 \ \ GPU并行计算结果,每个线程计算一条结果,得出M个区间的回溯区间.\\
3 \ \ 合并M个回溯区间,去除重复区间至J个区间.\\
4 \ \ 输出回溯区间.
\end{algorithmic}
\end{algorithm}

\Subsection{3.5\ \ 算法分析}
本文的算法是基于GPGPU的区间搜索算法,在算法实施的过程中,区间运算的过程会涉及浮点数运算,因此一般地我们选取区间右边界向上取近似值,左边界向下取近似值,以保证区间运算的结果正确性.基于牛顿区间算子的Hansen-Sengupta算法,可以排除不含根的区间并且可以削减区间的宽度,再利用回溯算法可以隔离出有穷个实根,确保了算法的可行性.本文的算法基于分支定界法和区间计算的基本法则,保证了算法的正确性.
由于本文中解决的多元多项式有有穷的个实解,当回溯算法计算出的区间组个数不再减少时,算法结束.即该算法具备算法的终止性.
\par
在分枝定界算法中,由于N个线程并行求解区间估值,则从并行的角度来看,该算法的时间复杂度为$O(n)$.同理在GPGPU 中的Hansen-Sengupta算法每个线程的时间复杂度为:矩阵求逆的复杂度$O(n^3)$加上区间矩阵乘法的时间复杂度$O(n^3)$和Guass迭代的时间复杂度$O(n)$.即总的时间复杂度为
$T(n)=2O(n^3)+O(n)$,即$O(n^3)$.
\par 本文的算法中同一个Block内每个线程处理的数据互不相关,即在同一步骤的操作中,线程之间的运算相互独立,其运算结果无需相互依赖,而同一Grid内的不同Block之间也不需要相互通信,因此,虽然在计算过程中该算法开辟了多个线程同时处理矩阵内的元素,但线程与线程之间无通信代价,相比于多线程的串行求解算法,该算法消除了其时间上的花销,提升了计算性能.


\Section{实验结果}
本文的实验环境为Intel Core i7-7700 CPU 3.60GHz,内存大小16G,GPGPU的型号为NVIDIA GeForce 1070 GTX,显存大小为8G,CUDA的版本为7.5.
\par
为了体现我们算法的可行性和作用,我们的大多数方程组来自实际应用和学术引用的内容,我们选取了XX个9个变元及以下的方程组.
\par
我们挑选了几个典型的方程组进行分析和详细介绍,其余的测试数据介绍列在了后面的表中.

\Subsection{4.1\ \ 实验分析}
{\HT 例1}\ \ katsura8 是一个来自物理磁力学上的9变元问题.方程如4.26:

\ay\begin{align}\label{E:4.1}
f(x1,\cdots,x9) = \left\{ \begin{array}{ll}
2x_9+2x_8+2x_7+2x_6+2x_5+2x_4+2x_3+2x_2+2x_1-1\\
2x_9^2+2x_8^2+2x_7^2+2x_6^2+2x_5^2+2x_4^2+2x_3^2+2x_2^2+x_1^2-x_1\\
2x_9x_8+2x_8x_7+2x_7x_6+2x_6x_5+2x_5x_4+2x_4x_3+2x_3x_2+2x_2x_1-x_2\\
2x_9x_7+2x_8x_6+2x_7x_5+2x_6x_4+2x_5x_3+2x_4x_2+2x_3x_1+x_2^2-x_3\\
2x_9x_6+2x_8x_5+2x_7x_4+2x_6x_3+2x_5x_2+2x_4x_1+2x_3x_2-x_4\\
2x_9x_5+2x_8x_4+2x_7x_3+2x_6x_2+2x_5x_1+2x_4x_2+x_3^2-x_5\\
2x_9x_4+2x_8x_3+2x_7x_2+2x_6x_1+2x_5x_2+2x_4x_3-x_6\\
2x_9x_3+2x_8x_2+2x_7x_1+2x_6x_2+2x_5x_3+x_4^2-x_7\\
2x_9x_2+2x_8x_1+2x_7x_2+2x_6x_3+2x_5x_4-x_8\\
\end{array} \right.
\end{align}
我们给出的方程的每个变元初始区间定为[-1,1].
首先我们使用全局的分枝定界区间估值,经过8轮的迭代之后区间解的数量开始下降.数据如表1:
\begin{center}
\centering{\small 表1\ \ 方程katsura8的分支定界结果}\\
\centerline{\small (Table 1\ \ B\&B Result of katsura8)}%%表中文标题下附英文标题翻译.
\vskip 1mm {\small
\begin{tabular*}{8.5cm}{ccccccc}
\hline
轮次 & 区间解个数 & 时间(s) &区间大小   \\
\hline
1 & 1 & 0 & 2 \\
2 & 511 & 0.001 & 1 \\
3 & 4847 & 0.01 & 0.5 \\
4 & 92880 & 0.2 & 0.25 \\
5 & 2549461 & 8 & 0.125 \\
6 & 76736464 & 38 & 0.0625 \\
7 & 794760638 & 6556 & 0.03125 \\
8 & 430650061 & 11203 & 0.015625\\
\hline
\end{tabular*}}
\end{center}


Hansen-Sengupta算法在变元区间较大时的削减效果不明显,我们选择从第8轮开始使用算法来进行区间的削减.
\begin{center}
\centering{\small 表2\ \ 方程katsura8的Hansen-Sengupta削减结果}\\
\centerline{\small (Table 2\ \ Hansen-Sengupta Result of katsura8)}%%表中文标题下附英文标题翻译.
\vskip 1mm {\small
\begin{tabular*}{8.5cm}{ccccccc}
\hline
轮次 & 区间解个数 & 区间解个数(削减后) &时间(s)   \\
\hline
8 & 430650061 & 4900601 & 1271\\
9 & 30098623 & 4347544 & 137\\
10 & 42617540 & 5532835 & 310\\
11 & 64267381 & 7946423 & 380\\
12 & 105056246  & 11571157 & 478\\
13 & 165616092 & 15474734 & 750\\
14 & 243760141 & 18711270 & 1013\\
15 & 295102270 & 20306174 & 1359\\
16 & 343840882 & 20242072 & 1624\\
\hline
\end{tabular*}}
\end{center}

此时区间组的数量基本趋于稳定,我们使用分枝定界法的回溯算法将区间组进行合并,至区间宽度为0.125时隔离出的实根个数为36个.

{\HT 例2}\ \ noon9 是一个神经网络中的Lotka-Volterra 系统,变元数为9个.方程如4.27:

\ay\begin{align}\label{E:4.1}
f(x1,\cdots,x9) = \left\{ \begin{array}{ll}
x_1x_2^2+x_1x_3^2+x_1x_4^2+x_1x_5^2+x_1x_6^2+x_1x_7^2+x_1x_8^2+x_1x_9^2-1.1x_1+1\\
x_2x_1^2+x_2x_3^2+x_2x_4^2+x_2x_5^2+x_2x_6^2+x_2x_7^2+x_2x_8^2+x_2x_9^2-1.1x_2+1\\
x_3x_1^2+x_3x_2^2+x_3x_4^2+x_3x_5^2+x_3x_6^2+x_3x_7^2+x_3x_8^2+x_3x_9^2-1.1x_3+1\\
x_4x_1^2+x_4x_2^2+x_4x_3^2+x_4x_5^2+x_4x_6^2+x_4x_7^2+x_4x_8^2+x_4x_9^2-1.1x_4+1\\
x_5x_1^2+x_5x_2^2+x_5x_3^2+x_5x_4^2+x_5x_6^2+x_5x_7^2+x_5x_8^2+x_5x_9^2-1.1x_5+1\\
x_6x_1^2+x_6x_2^2+x_6x_3^2+x_6x_4^2+x_6x_5^2+x_6x_7^2+x_6x_8^2+x_6x_9^2-1.1x_6+1\\
x_7x_1^2+x_7x_2^2+x_7x_3^2+x_7x_4^2+x_7x_5^2+x_7x_6^2+x_7x_8^2+x_7x_9^2-1.1x_7+1\\
x_8x_1^2+x_8x_2^2+x_8x_3^2+x_8x_4^2+x_8x_5^2+x_8x_6^2+x_8x_7^2+x_8x_9^2-1.1x_8+1\\
x_9x_1^2+x_9x_2^2+x_9x_3^2+x_9x_4^2+x_9x_5^2+x_9x_6^2+x_9x_7^2+x_9x_8^2-1.1x_9+1\\
\end{array} \right.
\end{align}
我们给出的方程的每个变元初始区间定为[-8,8].
首先我们使用全局的分枝定界区间估值,经过10轮的迭代之后区间解的数量开始下降.数据如表3:
\begin{center}
\centering{\small 表3\ \ 方程noon9的分支定界结果}\\
\centerline{\small (Table 3\ \ B\&B Result of noon9)}%%表中文标题下附英文标题翻译.
\vskip 1mm {\small
\begin{tabular*}{8.5cm}{ccccccc}
\hline
轮次 & 区间解个数 & 时间(s) &区间大小   \\
\hline
1 & 1 & 0 & 16 \\
2 & 512 & 0.001 & 8 \\
3 & 5120 & 0.001 & 4 \\
4 & 42176 & 0.01 & 2 \\
5 & 13511 & 0.2 & 1 \\
6 & 222941 & 1.5 & 0.5 \\
7 & 1156044 & 8 & 0.25 \\
8 & 11471246 & 102 & 0.125\\
9 & 33925040 & 300 & 0.0625\\
10 & 28775053 & 285 & 0.03125\\
\hline
\end{tabular*}}
\end{center}


我们选择从第10轮开始使用hansen-Sengupta算法来进行区间的削减.
\begin{center}
\centering{\small 表4\ \ 方程noon9的Hansen-Sengupta削减结果}\\
\centerline{\small (Table 4\ \ Hansen-Sengupta Result of noon9)}%%表中文标题下附英文标题翻译.
\vskip 1mm {\small
\begin{tabular*}{8.5cm}{ccccccc}
\hline
轮次 & 区间解个数 & 时间(s) &区间大小   \\
\hline
10 & 28775053 & 477 & 78\\
\hline
\end{tabular*}}
\end{center}
可以看出hansen-Sengupta对此方程的削减效果非常明显,我们此时即可以使用回溯算法来隔离实根,在区间宽度为0.00625时我们得到实根个数为19个.

{\HT 例3}\ \ kinema 是一个机器人运动学中的问题,变元数为9个.方程如4.28:

\ay\begin{align}\label{E:4.1}
f(x1,\cdots,x9) = \left\{ \begin{array}{ll}
z_1^2+z_2^2+z_3^2-12z_1-68\\
z_4^2+z_5^2+z_6^2-12z_5-68\\
z_7^2+z_8^2+z_9^2-24z_8-12z_9+100\\
z_1z_4+z_2z_5+z_3z_6-6z_1-6z_5-52\\
z_1z_7+z_2z_8+z_3z_9-6z_1-12z_8-6z_9+64\\
z_4z_7+z_5z_8+z_6z_9-6z_5-12z_8-6z_9+32\\
2z_2+2z_3-z_4-z_5-2z_6-z_7-z_9+18\\
z_1+z_2+2z_3+2z_4+2z_6-2z_7+z_8-z_9-38\\
z_1+z_3-2z_4+z_5-z_6+2z_7-2z_8+8\\
\end{array} \right.
\end{align}
我们给出的方程的每个变元初始区间定为[-32,32].
首先我们使用全局的分枝定界区间估值,经过10轮的迭代之后区间解的数量开始下降.数据如表5:
\begin{center}
\centering{\small 表5\ \ 方程kinema的分支定界结果}\\
\centerline{\small (Table 5\ \ B\&B Result of kinema)}%%表中文标题下附英文标题翻译.
\vskip 1mm {\small
\begin{tabular*}{8.5cm}{ccccccc}
\hline
轮次 & 区间解个数 & 时间(s) &区间大小   \\ \hline
1 & 1 & 0 & 64 \\
2 & 288 & 0.001 & 32 \\
3 & 5714 & 0.01 & 16 \\
4 & 56036 & 0.3 & 8 \\
5 & 407380 & 3 & 4 \\
6 & 4369735 & 28 & 2 \\
7 & 26247657 & 243 & 1 \\
8 & 87424465 & 1284 & 0.5\\
9 & 33925040 & 300 & 0.25\\
10 & 28775053 & 285 & 0.125\\
11 & 238223456 & 14930 & 0.0625\\
12 & 187213894 & 12250 & 0.03125\\
13 & 158874057 & 8450 & 0.015625\\
14 & 155682210 & 7321 & 0.0078125\\
15 & 153442353 & 7022 & 0.00390625\\
16 & 157313456 & 7127 & 0.001953125\\
\hline
\end{tabular*}}
\end{center}

此时方程的根的数量已经趋于稳定,我们使用Hansen-Sengupta算法对此方程进行削减不明显,消除的根数量太少,我们直接使用回溯算法隔离实根,在区间大小为0.03125时得到隔离的实根数量为8个.
\Subsection{4.2\ \ 实验结果}
在表6中,我们给出了我们测试方程的简介,有部分方程可以看做相似的不同变元的方程比如n-cyclic和eco,通过这些方程,变元的数量的变化我们可以看出问题规模对我们算法解决问题效率的影响.
在表7中我们列出了我们问题的变元数目,我们通过分枝定界法分离的区间组合下降到稳定数目的迭代次数,以及通过回溯算法在具体区间大小的隔离出的实根个数,算法的花费时间.由于时间和空间的大小的限制,部分方程无法在有限时间和空间内完成计算,在表格记为空白.
\begin{center}
\centering{\small 表6\ \ 方程简介}\\
\centerline{\small (Table 6\ \ Introduction to equations)}%%表中文标题下附英文标题翻译.
\vskip 1mm {\small
\begin{supertabular*}{14cm}{p{2cm}<{\centering}p{1.5cm}<{\centering}p{9.5cm}<{\centering}}
\hline
名称 & 变元个数 & 简介  \\ \hline
Mickey & 2 & 阐述同伦延拓算法的例子  \\
barry & 3 & 来自 PoSSo 方程集  \\
arnborg & 3 & 辅助解决7变元的方程 \\
noon3 & 3 &  3变元的神经网络Lotka-Volterra系统  \\
rediff3 & 3 & 三维反应扩散问题  \\
conform1 & 3 & 循环分子的正形分析，实例1  \\
morgan & 3 & 来自 PoSSo 方程集   \\
guakwa2 & 4 & 高斯求积，2个节点，2个权函数  \\
katsura3 & 4 & 来自物理磁力学上的4变元问题  \\
liu & 4 & 来自 PoSSo 方程集   \\
cyclic4 & 4 & 4循环问题  \\
caprasse & 4 & 来自 PoSSo 方程集\\
lorentz & 4 & 四维Lorentz吸引子的平衡问题\\
moeller5 & 4 & 来自 PoSSo 方程集  \\
noon4 & 4 & 4变元的神经网络Lotka-Volterra系统  \\
reimer4 & 4 & 4维reimer系统 \\
solotarev & 4 & 来自 PoSSo 方程集  \\
katsura4 & 5 & 来自物理磁力学上的5变元问题  \\
noon5 & 5 & 5变元的神经网络Lotka-Volterra系统\\
eco5 & 5 & 5维的环境学问题 \\
redeco5 & 5 & 削减的5维的环境学问题 \\
sparse5 & 5 & 5维稀疏对称多项式系统  \\
wright & 5 & A.H. Wright系统  \\
cyclic5 & 5 & 5循环问题  \\
reimer5 & 5 & 5维Reimer系统 \\
boon & 6 & 神经生理学问题  \\
eco6 & 6 & 6维的环境学问题  \\
katsura5 & 6 & 来自物理磁力学上的问题，6变元  \\
noon6 & 6 & 6变元的神经网络Lotka-Volterra系统  \\
gaukwa3 & 6 &  高斯求积，3个节点，3个权函数  \\
trinks1 & 6 & Trinks系统  \\
cyclic6 & 6 & 6循环问题 \\
extcyc6  & 6 & 拓展的6循环问题 \\
redeco6 & 6 & 削减的6维的环境学问题 \\
romin & 6 & ROMIN 机器人系统问题  \\
eco7 & 7 & 7维的环境学问题 \\
cyclic7 & 7 & 7循环问题 \\
redeco7 & 7 & 削减的7维的环境学问题 \\
katsura6 & 7 & 来自物理磁力学上的问题，7变元  \\
noon7 & 7 & 7变元的神经网络Lotka-Volterra系统 \\
eco8 & 8 & 8维的环境学问题  \\
puma& 8 &  PUMA机器人问题  \\
cyclic8 & 8 & 8循环问题 \\
redeco8 & 8 &削减的8维的环境学问题 \\
guakwa4 & 8 & 高斯求积，4个节点，4个权函数  \\
katsura7 & 8 & 来自物理磁力学上的问题，8变元 \\
noon8 & 8 & 8变元的神经网络Lotka-Volterra系统  \\
heart & 8 & heart-dipole problem  \\
SHEPWM & 8 & 有选择性消谐波脉宽调制系统(SHEPWM),8变元   \\
$s9_1$  & 8 & Galois理论的一个小系统 \\
eco9 & 9 & 9维的环境学问题  \\
katsura8 & 9 & 来自物理磁力学上的问题，9变元  \\
kinema & 9 & 机器人运动学中的问题  \\
noon9 & 9 & 9变元的神经网络Lotka-Volterra系统 \\
cyclic9 & 9 & 9循环问题 \\
\hline
\end{supertabular*}}
\end{center}


\begin{center}
\centering{\small 表7\ \ 测试集的完整数据}\\
\centerline{\small (Table 7\ \ Full Statics of Test Set)}%%表中文标题下附英文标题翻译.
\vskip 1mm {\small
\begin{supertabular*}{14cm}{p{2cm}<{\centering}p{1.5cm}<{\centering}p{2cm}<{\centering}p{1.8cm}<{\centering}p{2.3cm}<{\centering}p{2.2cm}<{\centering}}
\hline
名称 & 实根个数 & 初始区间 & 迭代次数 & 隔离实根个数 & 花费时间(s)\\ \hline
Mickey & 2 & [-2 2] & 7 & 2 & 0.001  \\
barry & 3 & [-32 32] & 14 & 2 & 0.001  \\
arnborg & 3 & [-16 16] & 13 & 8 & 0.020  \\
noon3 & 3 & [-8 8] & 12 & 7 & 0.001  \\
rediff3 & 3 & [-1 1] & 9 & 2 & 0.001  \\
conform1 & 3 & [-2 2] & 3 & 0 & 0.001  \\
morgan & 3 & [-32 32] & 13 & 2 & 0.001  \\
guakwa2 & 4 & [-4 4] & 10 & 2 & 0.001  \\
katsura3 & 4 & [-1 1] & 9 & 2 & 0.001 \\
liu & 4 & [-1 1] & 9 & 1 & 0.001  \\
cyclic4 & 4 & [-16 16] & 20 & 8 & 0.430 \\
caprasse & 4 & [-4 4] & 11 & 18 & 0.020  \\
lorentz & 4 & [-2 2] & 8 & 3 & 0.001  \\
moeller4 & 4 & [-2 2] & 11 & 8 & 0.001 \\
moeller5 & 4 & [-2 2] & 11 & 6 & 0.02  \\
noon4 & 4 &  [-8 8] & 15 & 15 & 0.020  \\
reimer4 & 4 & [-1 1] & 13 &  & 0.300  \\
solotarev & 4 & [-8 8] & 14 & 6& 0.001 \\
katsura4 & 5 & [-1 1] & 8 & 8 & 0.001 \\
noon5 & 5 & [-8 8] & 13 & 11 & 9.8  \\
eco5 & 5 & [-8 8] & 8 & 4 & 0.020  \\
redeco5 & 5 & [-8 8] & 12 & 4 & 0.001  \\
sparse5 & 5 & [-2 2] & 3 & 0 & 0.001  \\
wright & 5 & [-8 8] & 8 & 32 & 0.030  \\
cyclic5 & 5 & [-16 16] & 11 & 10 & 0.05  \\
reimer5 & 5 & [-1 1] &  &  &   \\
boon & 6 & [-2 2] & 9 & 8 & 0.01  \\
eco6 & 6 & [-8 8] & 9 & 4 & 0.004  \\
katsura5 & 6 & [-1 1] & 8 & 8 & 0.03  \\
noon6 & 6 & [-8 8] & 13 & 13 & 120.6  \\
gaukwa3 & 6 & [-4 4] & 12 & 0 & 66  \\
trinks1 & 6 & [-8 8] & 11 & 8 & 0.003  \\
cyclic6 & 6 & [-16 16] & 15 & 24 & 42 \\
extcyc6  & 6 & [-16 16] &  &  &   \\
redeco6 & 6 & [-16 16] & 12 & 4 & 0.02  \\
romin & 6 & [-1 1] & 13 & 4 & 0.003  \\
eco7 & 7 & [-8 8] & 8 & 8 & 0.02  \\
cyclic7 & 7 & [-16 16] & 15 &  & 3722  \\
redeco7 & 7 & [-16 16] &  &  &   \\
katsura6 & 7 & [-1 1] & 8 & 16 & 36.2 \\
noon7 & 7 & [-8 8] & 12 & 15 & 264  \\
eco8 & 8 & [-8 8] & 7 & 8 & 0.05  \\
puma & 8 & [-1 1] & 13 & 16 & 0.02  \\
cyclic8 & 8 & [-16 16] &  &  &   \\
redeco8 & 8 & [-16 16] &  &  &   \\
guakwa4 & 8 & [-16 16] &  &  &   \\
katsura7 & 8 & [-1 1] & 9 & 16 & 7150  \\
noon8 & 8 & [-8 8] & 11 & 17 & 924  \\
heart & 8 & [-16 16] &  &  &  \\
SHEPWM & 8 & [-1 1] & 5 &  &  \\
$s9_1$ & 8 & [-8 8] & 11 & 4 &0.001  \\
eco9 & 9 & [-8 8] &  &  &   \\
katsura8 & 9 & [-1 1] & 16 &  & 13360  \\
kinema & 9 & [-32 32] & 16& 8 & 56334 \\
noon9 & 9 & [-8 8] & 10 & 19 & 1021  \\
cyclic9 & 9 & [-16 16] &  &  &   \\
\hline
\end{supertabular*}}
\end{center}



\Section{结束语}
本文提出了一种基于GPGPU的非线性方程组全局区间解的高性能的算法.该算法在GPGPU 上实现了基于区间计算的分枝定界法,在GPGPU上实现了Hansen-Sengputa算法,在众核环境下以并行程序的思想对算法加以实现和性能调优,相比较串行算法,本文提出的算法在计算时间上更加省时,相比较计算非线性方程组的其他算法,本文的算法的保证了算法的正确性,可以获得确保正确的解,但是在解决很大规模变元问题上速度相对较慢.
下一步的工作将着眼于如何提升算法的计算效率上,本文采用的直接计算函数的区间函数值进行估值,在后续的工作中我们的工作考虑使用优化方法求函数在给定区间的最大最小值作为区间估值来获取更紧缩的区间,以提高分枝定界法缩减的速度.
\vskip 1cm {
%%特别提醒:参考文献中若为中文文献,请后附英文翻译.
\BeginRef %%{作者名, 文题, 刊, 书名, 年, 卷(期): 起止页码.}
\bibitem{ref1}Neumaier, Arnold. Interval methods for systems of equations. Vol. 37. Cambridge university press, 1990.%注:英文文献书排版格式
\bibitem{ref2}Boyd, Stephen, and Jacob Mattingley. Branch and bound methods. Notes for EE364b, Stanford University (2007): 2006-07.
\bibitem{ref3}Hansen, Eldon R. Computing zeros of functions using generalized interval arithmetic. {\it Interval Computations 3} (1993): 3-28.
\bibitem{ref4}Hansen E, Sengupta S. Bounding solutions of systems of equations using interval analysis.{\it BIT Numerical Mathematics}, 1981, 21(2): 203-211.
\bibitem{ref5}Hansen E. Interval forms of Newtons method. {\it Computing}, 1978, 20(2): 153-163.
\bibitem{ref6}Sharma G, Agarwala A, Bhattacharya B. A fast parallel Gauss Jordan algorithm for matrix inversion using CUDA. {\it Computers $\&$ Structures }, 2013, 128: 31-37.
\bibitem{ref7}Hansen E. Global optimization using interval analysis―the multi-dimensional case. {\it Numerische Mathematik}, 1980, 34(3): 247-270.
\bibitem{ref8}Nataraj P S V, Arounassalame M. An Interval Newton Method Based on the Bernstein Form for Bounding the Zeros of Polynomial Systems.{\it  Reliable Computing}, 2011, 15(2): 109-119.
\bibitem{ref9}Beck P D, Nehmeier M. Parallel Interval Newton Method on CUDA.{\it PARA}. 2012: 454-464.
\bibitem{ref10}Moore R E, Kearfott R B, Cloud M J. Introduction to interval analysis. {\it Society for Industrial and Applied Mathematics}, 2009.
\bibitem{ref11}Stradi-Granados B A. Interval Arithmetic for Nonlinear Problem Solving. {\it International Journal of Engineering Mathematics}, 2013, 2013.
\bibitem{ref12}Stahl V. Interval methods for bounding the range of polynomials and solving systems of nonlinear equations, 1995.
\bibitem{ref13}Hansen E R. On solving systems of equations using interval arithmetic. {\it Mathematics of Computation}, 1968, 22(102): 374-384.
\bibitem{ref14} B.Buchberger, An Algorithm for Finding the Basis Elements the Residue Class Ring of a Zero Dimensional Polynomial Idea, PhD thesis, Mathematical Institute, University of Innsbruck,Austria,  English translation published in the Journal of Symbolic Computation, 41:475-511, 2006.
\bibitem{ref15}P.Emeliyanenko, A Complete Modular Resultant Algorithm Targeted for Realization on Graphics Hardware, Proceedings of ACM PASCO 2010, pp.35-43, France, 2010.
\bibitem{ref16}S.Inoue, Y.Sato: On the Parallel Computation of Comprehensive Groebner Systems. PASCO 2007: 99-101.
\bibitem{ref17}X.Li, M.Maza, Multithreaded Parallel Implementation of Arithmetic Operations Modulo a Triangular Set, Proceedings of the 2007 international workshop on Parallel symbolic computation, July 27-28, 2007, London, Ontario, Canada.
\bibitem{ref18}C.Stussak, P. Schenzel, Parallel Computation of Bivariate Polynomial Resultants on Graphics Processing Units, Proceedings of Para 2010, Iceland, 2010.
\bibitem{ref19}P.Wang, Parallel Polynomial Operations on SMPs: an Overview, Journal of Symbolic Computation,21:397-410,1996.
\bibitem{ref20}L.Yang, X.Hou, Z.Zeng, A Complete Discrimination System  for Polynomials, Science in China Series E 39:628-646, 1996.
\bibitem{ref21}高小山、王定康、裘宗燕、杨宏,方程求解与机器证明:基于MMP的问题求解,科学出版社,北京,2006.\\
\noindent(GAO X S,WANG D K,PEI Z Y,YANG H,Equation Solving and Machine Proof: problem solving based on MMP,{\it Science Press},Beijing,2006.)
\bibitem{ref22}林东岱, 武永卫, 杨宏, 并行多项式最大公因子计算, 2003中国计算机大会, 900-905, 2003.\\
\noindent(LIN D D,WU Y W,YANG H.Parallel Computation for Polynomial GCD,CNCC 2003,900-905, 2003.)
\bibitem{ref23}王东明,消去法及其应用,科学出版社,北京,2002.\\
\noindent(WANG D M,Elimination of the Method and Its Application,{\it Science Press},Beijing,2002.)
\bibitem{ref24}吴文俊,数学机械化,科学出版社,北京,2003.\\
\noindent(WU W J,Mathematics Mechanization,{\it Science Press},Beijing,2003)
\bibitem{ref25}杨路、张景中,侯晓荣,非线性代数方程组与定理机器证明,上海科技教育出版社,上海,1996.\\
\noindent(YANG L,ZHANG J Z,HOU X Y,Nonlinear Algebraic Equation System and Automated Theorem Proving,{\it Shanghai Technology Education Press},Shanghai,1996.)
\bibitem{ref26}杨路,夏碧灿,不等式机器证明与自动发现,科学出版社,北京,2008.\\
\noindent(YANG L,XIA B C,The Inequality Machine Proves and the Automatic Discovery,{\it Science Press},Beijing,2008.)
\bibitem{ref27}曾振柄, 张景中. 基于矩形区域剖分的不等式机器证明方法―以 Zirakzadeh 的一个几何不等式为例. 系统科学与数学, 2010 (11): 1430-1458.\\
\noindent (ZENG Z B, ZHANG J Z. A Mechanical Proof to a Geometric Inequality of Zirakzadeh Through Rectangular Partition of Polyhedra,{\it Journal of System Science and Mathematical},2010 (11): 1430-1458.)
\bibitem{ref28}单美静. 求解非线性实代数系统的混合算法研究. 博士论文,华东师范大学, 2008.\\
\noindent(SHAN M J,Study on Solving Real Nonlinear Algebra Systems by Hybird Method,Ph.D Thesis.East China Normal University,2008.)
\EndRef

} %请将附录部分放于此处编排.


\end{document}
